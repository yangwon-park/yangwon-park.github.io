---
layout: single
title: 백준 2217 - 로프 (Python3)
categories: baekjoon
tag: [python, algorithm, coding_test]
toc: true 
author_profile: false
sidebar:
    nav: "docs"
---

## 코드

```python
n = int(input())

# 밧줄
rope = [int(input()) for _ in range(n)]

# 각 로프들로 만들 수 있는 최대 중량을 담을 리스트
answer = []

# 기능 구현
def solution(n, rope, answer):
    
    # 편의를 위해 rope 내림차순 정렬
    rope.sort(reverse=True)

    for i in range(n):
        # 내림차순된 rope의 각 요소와 인덱스+1의 값을 곱하고
        # answer 리스트에 저장
        answer.append(rope[i] * (i+1))

    print(max(answer))
    
solution(n, rope, answer)
```



## 문제 해설

처음 문제 풀이에 시도했을 때 마땅한 규칙이 보이지 않아 생각보다 애를 먹은 문제.

문제의 핵심 로직은 다음과 같다.

---

1. k개의 로프를 이용하여 중량 w의 물체를 드려고 하면 균일하게 w/k의 힘이 가해진다. (kg 생략)
2. 만약 로프 10 20 30 40이 주어질 때, 로프 별로 견딜 수 있는 최대 중량을 주어진 모든 로프들에 돌아가면서 하나씩 대입하여 그 중량을 견딜 수 있는 로프의 개수를 구해보면 아래와 같은 결과가 나온다.
   - 10 : 4개, 20 : 3개, 30 : 2개, 40 : 1개
   - 즉, 40의 무게를 견딜 수 있는 로프는 1개, 30은 2개, 20은 3개, 10은 1개
3. 위의 결과를 토대로 1번의 조건에 맞추어 w의 최댓값을 구해보면 아래와 같다.
   - 식 : 주어진 로프 중 견딜 수 있는 최대 중량 중 최솟값 * 주어진 로프의 개수
   - 40 => 40 * 1 => w의 최댓값 : 40
   - 30 => 30 * 2 (40, 30 2개) => w의 최댓값 : 60
   - 20 => 20 * 3 (40, 30, 20 3개) => w의 최댓값 : 60
   - 10 => 10 * 4 (40, 30, 20, 10 4개) => w의 최댓값 : 40
4. 3번의 결과를 토대로 코드를 짜보면 위의 코드와 같은 결과가 나온다.

---

위의 로직 중 3번을 눈치채는 과정에 생각보다 애를 먹었다 ㅠㅠ 다양한 유형의 문제를 많이 풀어보고 거기서 나오는 문제 풀이의 경험치를 높여야겠다.

